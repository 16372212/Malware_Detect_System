package service

import (
	"MalwareDetect/common"
	"MalwareDetect/dao"
	"MalwareDetect/model"
	"MalwareDetect/model/vo"
	"MalwareDetect/util/errors"
	"MalwareDetect/util/strs"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	"golang.org/x/crypto/bcrypt"
	"log"
)

type UserService struct {
	UserDaoInstance dao.UserDao
}

func NewUserService() *UserService {
	instance := dao.NewUserDao()
	instance.DB.AutoMigrate(model.User{})
	return &UserService{UserDaoInstance: instance}
}

func (u UserService) Login(ctx *gin.Context) (string, error) {
	DB := common.GetDB()

	var req = &vo.RegisterRequest{}
	err := ctx.ShouldBind(&req)
	if err != nil {
		return "", err
	}

	user, exist := u.checkTelephoneExist(DB, req.Telephone)
	if !exist {
		return "", errors.New("user not exist")
	}

	// check whether password match
	log.Println(fmt.Sprintf("user: '%v'", user.Telephone))
	//if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil {
	//	log.Printf("[UserHandler] password wrong")
	//	return "", err
	//}

	token, err := common.ReleaseToken(user)
	if err != nil {
		log.Printf("token generate error: %v", err)
		return "", err
	}

	return token, nil
}

func (u UserService) checkTelephoneExist(db *gorm.DB, telephone string) (model.User, bool) {
	var user model.User
	db.Where("name = ?", telephone).First(&user)
	if user.ID == 0 {
		return user, false
	}
	return user, true
}

func (u UserService) Register(ctx *gin.Context) (string, error) {
	DB := common.GetDB()
	var req = &vo.RegisterRequest{}
	ctx.ShouldBind(req)

	log.Println(fmt.Sprintf("[UserHandler] req:%+v", req))
	if err := u.checkRegisterParams(req); err != nil {
		return "", err
	}
	log.Println(fmt.Sprintf("[UserHandler] after check, req:%+v", req))

	if _, exist := u.checkTelephoneExist(DB, req.Telephone); exist {
		return "", errors.New("user already exist")
	}

	newUser, err := u.createUser(DB, req)
	if err != nil {
		log.Println(fmt.Sprintf("[UserHandler] create user fail, error:%+v", err.Error()))
		return "", errors.New("internal error")
	}

	token, err := common.ReleaseToken(newUser)
	if err != nil {
		return "", errors.New("internal error")
	}
	return token, nil
}

func (u UserService) checkRegisterParams(param *vo.RegisterRequest) error {
	if len(param.Name) == 0 {
		param.Name = strs.RandomString(5)
	}
	if len(param.Password) < 6 {
		return errors.New("length of password should not less than 6")
	}
	if len(param.Telephone) != 11 {
		return errors.New("length of telephone should be 11")
	}
	return nil
}

func (u UserService) createUser(DB *gorm.DB, param *vo.RegisterRequest) (model.User, error) {
	newUser := model.User{}
	// 加密保存密码
	hasePassword, err := bcrypt.GenerateFromPassword([]byte(param.Password), bcrypt.DefaultCost)
	if err != nil {
		return newUser, errors.New("password hash failed")
	}

	newUser.Password = string(hasePassword)
	newUser.Name = param.Name
	newUser.Telephone = param.Telephone
	log.Println(fmt.Sprintf("[UserHandler] writing param:%+v to DB", newUser))

	DB.Create(&newUser)
	return newUser, nil
}

func (u UserService) UserInfo(ctx *gin.Context) model.UserDto {
	log.Println(fmt.Sprintf("[UserInfo] ???"))
	user, _ := ctx.Get("user")

	return model.ToUserDto(user.(model.User))
}
